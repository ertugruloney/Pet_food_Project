{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Code for Reading in Data, Etc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 92,
   "metadata": {},
   "outputs": [],
   "source": [
    "import xlrd\n",
    "import pprint\n",
    "\n",
    "numItems = 7 #79\n",
    "numWeeks = 14 #52\n",
    "WOS_warehouse = 15\n",
    "WOS_vendor = 15\n",
    "\n",
    "weeks = range(1, numWeeks + 1)\n",
    "\n",
    "def read_data(file):\n",
    "    loc = (file)\n",
    "    wb = xlrd.open_workbook(loc)\n",
    "\n",
    "    itemMapping = wb.sheet_by_index(0)\n",
    "    itemInfo = {}\n",
    "\n",
    "    for rowIndex in range(3,numItems+3):\n",
    "        itemID = str(int(itemMapping.cell_value(rowIndex, 0)))\n",
    "        itemInfo[itemID] = {}\n",
    "        itemInfo[itemID]['unitWt'] = str(itemMapping.cell_value(rowIndex, 2))\n",
    "        itemInfo[itemID]['leadTime'] = int(itemMapping.cell_value(rowIndex, 3))\n",
    "        itemInfo[itemID]['MOQ'] = float(itemMapping.cell_value(rowIndex, 4))\n",
    "        itemInfo[itemID]['priceBreaks'] = {}\n",
    "        #itemInfo[itemID]['priceBreaks'][0] = 1000\n",
    "        for priceBreakIndex in range(5,21):\n",
    "            if itemMapping.cell_type(rowIndex, priceBreakIndex) != 1:\n",
    "                unitCost = itemMapping.cell_value(rowIndex, priceBreakIndex)\n",
    "                if unitCost != '':\n",
    "                    qtyBreakpoint = itemMapping.cell_value(2, priceBreakIndex)\n",
    "                    itemInfo[itemID]['priceBreaks'][qtyBreakpoint] = unitCost\n",
    "\n",
    "    demands = {}\n",
    "    bagDemand = wb.sheet_by_index(2)\n",
    "    for rowIndex in range(3,numItems + 3):\n",
    "        item = str(int(bagDemand.cell_value(rowIndex, 0)))\n",
    "        #demands[item] = []\n",
    "        for colIndex in range(1,numWeeks + 1):\n",
    "            demand = bagDemand.cell_value(rowIndex, colIndex)\n",
    "            demands[item, colIndex]= round(demand)\n",
    "    return itemInfo, demands\n",
    "\n",
    "def print_order_plan(order_plan):\n",
    "    for item in order_plan.keys():\n",
    "        print(*order_plan[item], sep='\\t')\n",
    "        \n",
    "def print_table(table):\n",
    "    for item in table.keys():\n",
    "        print(*table[item], sep='\\t')\n",
    "        \n",
    "def print_dict(mydict, items):\n",
    "    for i in items:\n",
    "        mylist = [mydict[i,t] for t in weeks]\n",
    "        print(*mylist, sep=' \\t')\n",
    "        \n",
    "def get_max_inventory_values(demands, items, weeks, WOS):\n",
    "    totalDemand = [sum([demands[item, week] for item in items]) for week in weeks]\n",
    "    avgDemand = sum(totalDemand)/len(totalDemand)\n",
    "    totalDemand.extend([avgDemand] * (WOS - 1))\n",
    "    maxInventories = [ sum([totalDemand[index] for index in range(week, week + WOS - 1)]) for week in weeks]\n",
    "    return maxInventories\n",
    "\n",
    "def round_and_print_list(mylist):\n",
    "    newlist = [round(x) for x in mylist]\n",
    "    print(*newlist, sep='\\t')\n",
    "\n",
    "def compute_inventory_levels(item, order_plan, demands):\n",
    "    invLevels = [0]*numWeeks\n",
    "    invLevels[0] = order_plan[0] - demands[0]\n",
    "    for week in range(1,numWeeks):\n",
    "        invLevels[week] = invLevels[week-1] + order_plan[week] - demands[week]\n",
    "    return invLevels\n",
    "\n",
    "def compute_total_inventory_levels(order_plan, demands):\n",
    "    invLevels = [0]*numWeeks\n",
    "    for week in range(numWeeks):\n",
    "        invLevels[week] = sum([compute_inventory_levels(item, order_plan[item], demands[item])[week] for item in demands.keys()])\n",
    "    return invLevels\n",
    "\n",
    "def check_inventory_space_constraints(invLevels, demands, WOS):\n",
    "    maxValues = get_max_inventory_values(demands, WOS)\n",
    "    feasible = True\n",
    "    for week in range(numWeeks):\n",
    "        if invLevels[week] > maxValues[week]:\n",
    "            feasible = False\n",
    "    return feasible\n",
    "\n",
    "def get_order_upper_bound(demands, maxInventory, item, week):\n",
    "    totalDemandForItem = sum([demands[item, w] for w in weeks if w >= week])\n",
    "    return min(totalDemandForItem, maxInventory[week])\n",
    "\n",
    "def get_order_upper_bounds(demands, maxInventory):\n",
    "    upper_bounds = {}\n",
    "    for i in items:\n",
    "        upper_bounds[i] = [0]*numWeeks\n",
    "        for week in weeks:\n",
    "            upper_bounds[i][week] = get_order_upper_bound(demands, maxInventory, i, week)\n",
    "    return upper_bounds"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 93,
   "metadata": {},
   "outputs": [],
   "source": [
    "itemsInfo, demands = read_data(\"IE 402 - Group project - PPF - Template.xlsx\")\n",
    "items = itemsInfo.keys()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
